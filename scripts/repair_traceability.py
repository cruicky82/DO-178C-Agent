#!/usr/bin/env python3
"""
repair_traceability.py â€” DO-178C Traceability Repair Tool

Fixes existing databases where HLRs have NULL parent_sys by:
1. Inferring the behavioral domain from HLR id pattern
2. Creating missing system requirements
3. Setting parent_sys on all orphaned HLRs

Usage:
    python repair_traceability.py --db <traceability.db>
    python repair_traceability.py --db <traceability.db> --dry-run
"""

import argparse
import os
import re
import sqlite3
import sys

# Domain inference patterns (match against HLR id or text)
DOMAIN_PATTERNS = {
    'INGEST':  re.compile(r'INGEST|FEED|POLL|STREAM|LISTENER|DUMP1090|ADSB|OPENSKY', re.I),
    'FUSION':  re.compile(r'FUSION|ASSOCIATE|FILTER|ALIGN|SMOOTH|PROJECTOR|TRACKER|KCTRACK', re.I),
    'UI':      re.compile(r'UI|COMPONENT|VIEW|INDICATOR|HUD|PANEL|DISPLAY|FRONTEND', re.I),
    'SITL':    re.compile(r'SITL|SIMULATION|MOCK|REPLAY', re.I),
    'SORA':    re.compile(r'SORA|RISK|VOLUME|LEGEND|OVERLAP', re.I),
    'TERRAIN': re.compile(r'TERRAIN|TILE|GEOTIFF|ELEVATION|CLIPPING', re.I),
    'SAFETY':  re.compile(r'ALERT|SAFE|THRESHOLD|WARNING|CRITICAL|EMERGENCY', re.I),
    'CORE':    re.compile(r'CORE|INTERNAL|LIB|UTILS|CONFIG|METRIC|BUS|NATS|WS|GATEWAY|SERVER|API', re.I),
}

DOMAIN_DESCRIPTIONS = {
    'INGEST':  'The system shall provide data ingestion capabilities for external sensor feeds.',
    'FUSION':  'The system shall correlate and filter multi-source tracking data.',
    'UI':      'The system shall render operator displays and controls.',
    'SITL':    'The system shall support simulation and replay of operations.',
    'SORA':    'The system shall compute SORA risk assessments and airspace volumes.',
    'TERRAIN': 'The system shall process and display terrain elevation data.',
    'SAFETY':  'The system shall monitor safety thresholds and issue alerts.',
    'CORE':    'The system shall provide core infrastructure services.',
    'OTHER':   'The system shall provide auxiliary software services.',
}


def infer_domain(hlr_id, hlr_text):
    """Infer the behavioral domain from HLR id and text."""
    combined = f"{hlr_id} {hlr_text}"
    for domain, pattern in DOMAIN_PATTERNS.items():
        if pattern.search(combined):
            return domain
    return 'OTHER'


def main():
    parser = argparse.ArgumentParser(description='Repair DO-178C traceability gaps')
    parser.add_argument('--db', required=True, help='Path to traceability.db')
    parser.add_argument('--dry-run', action='store_true', help='Preview changes without writing')
    args = parser.parse_args()

    db = os.path.abspath(args.db)
    if not os.path.isfile(db):
        print(f"ERROR: Database not found: {db}")
        sys.exit(1)

    conn = sqlite3.connect(db)
    conn.execute("PRAGMA foreign_keys = ON;")
    conn.row_factory = sqlite3.Row

    # Find all HLRs with NULL parent_sys
    orphans = conn.execute("""
        SELECT id, text, is_derived FROM high_level_requirements
        WHERE parent_sys IS NULL
        ORDER BY id
    """).fetchall()

    if not orphans:
        print("All HLRs already have a parent system requirement. Nothing to repair.")
        conn.close()
        return

    print(f"=== DO-178C Traceability Repair ===")
    print(f"Database: {db}")
    print(f"Orphaned HLRs: {len(orphans)}")
    print()

    # Group orphans by inferred domain
    domain_groups = {}
    for row in orphans:
        domain = infer_domain(row['id'], row['text'])
        if domain not in domain_groups:
            domain_groups[domain] = []
        domain_groups[domain].append(row['id'])

    # Create system requirements and repair links
    cursor = conn.cursor()
    repaired = 0

    for domain, hlr_ids in sorted(domain_groups.items()):
        sys_id = f"SYS_{domain}_001"
        sys_text = DOMAIN_DESCRIPTIONS.get(domain,
            f"The system shall provide {domain.lower()} capabilities.")

        print(f"  Domain: {domain}")
        print(f"    System Req: {sys_id}")
        print(f"    HLRs to repair: {len(hlr_ids)}")

        if not args.dry_run:
            # Create system requirement if it doesn't exist
            cursor.execute("""
                INSERT INTO system_requirements (id, text, source)
                VALUES (?, ?, 'Auto-generated by repair_traceability.py')
                ON CONFLICT(id) DO NOTHING
            """, (sys_id, sys_text))

            # Set parent_sys on all orphaned HLRs in this domain
            for hlr_id in hlr_ids:
                cursor.execute("""
                    UPDATE high_level_requirements
                    SET parent_sys = ?, source = ?,
                        updated_at = datetime('now')
                    WHERE id = ? AND parent_sys IS NULL
                """, (sys_id, sys_id, hlr_id))
                repaired += 1

        for hid in hlr_ids[:5]:
            print(f"      {hid}")
        if len(hlr_ids) > 5:
            print(f"      ... and {len(hlr_ids)-5} more")
        print()

    if not args.dry_run:
        conn.commit()
        print(f"Repaired {repaired} HLRs across {len(domain_groups)} domains.")

        # Verify
        remaining = conn.execute("""
            SELECT COUNT(*) FROM high_level_requirements WHERE parent_sys IS NULL
        """).fetchone()[0]
        if remaining == 0:
            print("[PASS] All HLRs now trace to a system requirement.")
        else:
            print(f"[WARN] {remaining} HLRs still have NULL parent_sys.")
    else:
        print(f"[DRY-RUN] Would repair {len(orphans)} HLRs across {len(domain_groups)} domains.")

    conn.close()


if __name__ == '__main__':
    main()
